// Exemplos de criacao e manipulacao de arvores binarias

#define ERRO 		0
#define OK 		 	1
#define RED			1
#define BLACK		0

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

// estrutura de um elemento, no da arvore
struct sNo {
	int valor;
	struct sNo *esq;
	struct sNo *dir;
	int cor;
};

typedef struct sNo sNo;
typedef struct sNo* ArvLLRB;

sNo *inicializa();
sNo *cria(int valor, sNo *sae, sNo *sad, int *res);

int e_vazia(sNo *a);
int busca(int valor, sNo *a);
int insere_ArvLLRB(ArvLLRB* raiz, int valor);
int remove_ArvLLRB(ArvLLRB* raiz, int valor);
int cor(struct sNo* h);
void trocaCor(struct sNo* h);
struct sNo* rotacionaEsquerda(struct sNo* a);
struct sNo* rotacionaDireita(struct sNo* a);
struct sNo* move2EsqRED(struct sNo* a);
struct sNo* move2DirRED(struct sNo* a);
struct sNo* balancear(struct sNo* a);
struct sNo* insereNO(struct sNo* a, int valor, int *resp);
struct sNo* removerMenor(struct sNo* a);
struct sNo* procuraMenor(struct sNo* atual);
struct sNo* remove_NO(struct sNo* a, int valor);

void imprime_pre_order(sNo *a);
void imprime_in_order(sNo *a);
void imprime_pos_order(sNo *a);
void imprime_textual(sNo *a);

int altura(sNo *a);
int qtdeNos(sNo *a);
int qtdeFolhas(sNo *a);

int main() {
	sNo *a0, *a1, *a2, *a3, *a4, *a5; // exemplo 1
	int r, v;

	/*  Exemplo 1 ------------------------------------------------------------------------
	Criando a seguinte arvore:
	0
	/   \
	1     2
	\   / \
	3  4   5
	*/
	a3 = cria(3, inicializa(), inicializa(), &r);
	a4 = cria(4, inicializa(), inicializa(), &r);
	a5 = cria(5, inicializa(), inicializa(), &r);
	a1 = cria(1, inicializa(), a3, &r);
	a2 = cria(2, a4, a5, &r);
	a0 = cria(0, a1, a2, &r);

	if (r) {
		printf(":: Arvore a0 criada!");
		printf("\n:: Pre-order: ");
		imprime_pre_order(a0);
		printf("\n:: In-order: ");
		imprime_in_order(a0);
		printf("\n:: Pos-order: ");
		imprime_pos_order(a0);
		printf("\n:: Textual: ");
		imprime_textual(a0);
		printf("\n:: a0 possui %d nos", qtdeNos(a0));
		printf("\n:: a0 possui %d folhas", qtdeFolhas(a0));
		printf("\n:: a0 possui altura de %d \n", altura(a0));

		getch();
	}
	else printf("=> Erro na criacao da arvore!\n");
}

// definicao recursiva de arvore binaria:
// 1) uma arvore binaria eh vazia, ou
sNo *inicializa(void) {
	return NULL;
}
// 2) eh composta por uma raiz e duas subarvores (esquerda e direita)
sNo *cria(int valor, sNo *sae, sNo *sad, int *res) {
	sNo *no;
	no = (sNo *)malloc(sizeof(sNo));
	if (no == NULL) *res = ERRO;
	else {
		no->esq = sae;
		no->dir = sad;
		no->valor = valor;
		*res = OK;
	}
	return no;
}

struct sNo* rotacionaEsquerda(struct sNo* a) {
	struct sNo* b = a->dir;
	a->dir = b->esq;
	b->esq = a;
	b->cor = a->cor;
	a->cor = RED;
	return b;
}
struct sNo* rotacionaDireita(struct sNo* a) {
	struct sNo* b = a->esq;
	a->esq = b->dir;
	b->dir = a;
	b->cor = a->cor;
	a->cor = RED;
	return b;
}

struct sNo* move2EsqRED(struct sNo* a) {
	trocaCor(a);
	if (cor(a->dir->esq) == RED) {
		a->dir = rotacionaDireita(a->dir);
		a = rotacionaEsquerda(a);
		trocaCor(a);
	}
	return a;
}

struct sNo* move2DirRED(struct sNo* a) {
	trocaCor(a);
	if (cor(a->esq->esq) == RED) {
		a = rotacionaDireita(a);
		trocaCor(a);
	}
	return a;
}

struct sNo* balancear(struct sNo* a) {
	if (cor(a->dir) == RED)
		a = rotacionaEsquerda(a);
	if (a->esq != NULL && cor(a->dir) == RED && cor(a->esq->esq) == RED)
		a = rotacionaDireita(a);
	if (cor(a->esq) == RED && cor(a->dir) == RED)
		trocaCor(a);
	return a;
}

struct sNo* insereNO(struct sNo* a, int valor, int *resp) {
	if (a == NULL) {
		struct sNo *novo;
		novo = (struct sNo*)malloc(sizeof(struct sNo));
		if (novo == NULL) {
			*resp = 0;
			return NULL;
		}
		novo->valor = valor;
		novo->cor = RED;
		novo->esq = NULL;
		novo->dir = NULL;
		*resp = 1;
		return novo;
	}
	if (valor == a->valor)
		*resp = 0;
	else {
		if (valor < a->valor)
			a->esq = insereNO(a->esq, valor, resp);
		else
			a->dir = insereNO(a->dir, valor, resp);
	}
	if (cor(a->dir) == RED && cor(a->esq) == BLACK)
		a = rotacionaEsquerda(a);
	if (cor(a->esq) == RED && cor(a->esq->esq) == RED)
		a = rotacionaDireita(a);
	if (cor(a->esq) == RED && cor(a->dir) == RED)
		trocaCor(a);
	return a;
}

struct sNo* removerMenor(struct sNo* a) {
	if (a->esq == NULL) {
		free(a);
		return NULL;
	}
	if (cor(a->esq) == BLACK && cor(a->esq->esq) == BLACK)
		a = move2EsqRED(a);
	a->esq = removerMenor(a->esq);
	return balancear(a);
}

struct sNo* procuraMenor(struct sNo* atual) {
	struct sNo *no1 = atual;
	struct sNo *no2 = atual->esq;
	while (no2 != NULL) {
		no1 = no2;
		no2 = no2->esq;
	}
	return no1;
}

struct sNo* remove_NO(struct sNo* a, int valor) {
	if (valor < a->valor) {
		if (cor(a->esq) == BLACK && cor(a->esq->esq) == BLACK)
			a = move2EsqRED(a);
		a->esq = remove_NO(a->esq, valor);
	}
	else {
		if (cor(a->esq) == RED)
			a = rotacionaDireita(a);
		if (valor == a->valor && (a->dir == NULL)) {
			free(a);
			return NULL;
		}
		if (cor(a->dir) == BLACK && cor(a->dir->esq) == BLACK)
			a = move2DirRED(a);
		if (valor == a->valor) {
			struct sNo* x = procuraMenor(a->dir);
			a->valor = x->valor;
			a->dir = removerMenor(a->dir);
		}
		else
			a->dir = remove_NO(a->dir, valor);
	}
	return balancear(a);
}

int cor(struct sNo* h) {
	if (h == NULL)
		return BLACK;
	else
		return h->cor;
}

void trocaCor(struct sNo* h) {
	h->cor = !h->cor;
	if (h->esq != NULL)
		h->esq->cor = !h->esq->cor;
	if (h->dir != NULL)
		h->dir->cor = !h->dir->cor;
}

int insere_ArvLLRB(ArvLLRB* raiz, int valor) {
	int resp;
	*raiz = insereNO(*raiz, valor, &resp);
	if ((*raiz) != NULL)
		(*raiz)->cor = BLACK;
	return resp;
}

int remove_ArvLLRB(ArvLLRB *raiz, int valor) {
	if (busca(valor, *raiz)) {
		struct sNo* a = *raiz;
		*raiz = remove_NO(a, valor);
		if (*raiz != NULL)
			(*raiz)->cor = BLACK;
		return 1;
	}
	else
		return 0;
}

// verifica se arvore a eh vazia
int e_vazia(sNo *a) {
	return a == NULL;
}

// indica ocorrencia ou nao do valor na arvore
int busca(int valor, sNo *a) {
	if (e_vazia(a))
		return 0;
	else // encontra ou busca a esquerda ou busca a direita, interrompe assim que achar
		return a->valor == valor || busca(valor, a->esq) || busca(valor, a->dir);
}

// impressao dos nos da arvore:
//    -> pre-order/pré-ordem: trata raiz, percorre sae, percorre sad
//    -> in-order/ordem simétrica: percorre sae, trata raiz, percorre sad
//    -> pos-order/pós-ordem: percorre sae, percorre sad, trata raiz
void imprime_pre_order(sNo *a) {
	if (!e_vazia(a)) {
		printf(" %d ", a->valor);
		imprime_pre_order(a->esq);
		imprime_pre_order(a->dir);
	}
}

void imprime_in_order(sNo *a) {
	if (!e_vazia(a)) {
		imprime_in_order(a->esq);
		printf(" %d ", a->valor);
		imprime_in_order(a->dir);
	}
}

void imprime_pos_order(sNo *a) {
	if (!e_vazia(a)) {
		imprime_pos_order(a->esq);
		imprime_pos_order(a->dir);
		printf(" %d ", a->valor);
	}
}

// representacao textual, percurso eh pre-order
void imprime_textual(sNo *a) {
	if (e_vazia(a))
		printf("<>");
	else {
		printf("<%d", a->valor);
		imprime_textual(a->esq);
		imprime_textual(a->dir);
		printf(">");
	}
}

// retorna a altura da arvore
int altura(sNo *a) {
	int ae, ad;

	if (a == NULL)
		return -1; // arvore vazia tem altura -1 
	else if (a->esq == NULL && a->dir == NULL)
		return 0; // arvore com apenas raiz tem altura 0
	else {
		ae = altura(a->esq);
		ad = altura(a->dir);
		if (ae > ad)
			return 1 + ae;
		else
			return 1 + ad;
	}
}

// retorna a quantidade de nos da arvore
int qtdeNos(sNo *a) {
	if (a == NULL)
		return 0;
	else
		return 1 + qtdeNos(a->esq) + qtdeNos(a->dir);
}

// retorna a quantidade de folhas (nos sem filhos) da arvore
int qtdeFolhas(sNo *a) {
	if (a == NULL)
		return 0;
	if (a->esq == NULL && a->dir == NULL)
		return 1;
	return qtdeFolhas(a->esq) + qtdeFolhas(a->dir);
}
